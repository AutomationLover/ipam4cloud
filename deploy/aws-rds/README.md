# AWS RDS Deployment

Deploys IPAM4Cloud with AWS RDS PostgreSQL database and application containers on EC2.

## Overview

- **Database**: AWS RDS PostgreSQL (managed service)
- **Backend**: FastAPI backend container on EC2
- **Frontend**: Vue.js admin and read-only portals on EC2
- **AWS Sync**: Container for VPC synchronization on EC2

The database runs on AWS RDS (managed PostgreSQL), while application containers run on a single EC2 instance using Docker Compose.

## Prerequisites

1. **AWS Account** with appropriate permissions (RDS, EC2, VPC)
2. **Terraform** >= 1.0 installed
3. **AWS CLI** configured with credentials
4. **VPC and Subnets** IDs where you want to deploy
   - At least 2 subnets in different Availability Zones for RDS (required even for single-AZ instances)
   - 1 subnet for EC2 instance

## Quick Start

### 1. Configure Variables

```bash
cd deploy/aws-rds
```

Copy the example files:
```bash
cp terraform.tfvars.example terraform.tfvars
cp network.auto.tfvars.example network.auto.tfvars
```

Edit `terraform.tfvars` and update:
- `aws_region`: AWS region for infrastructure deployment
- `aws_sync_region`: AWS region for VPC sync operations (can be different)
- `aws_account_id`: Your AWS Account ID
- `project_name`: Your project name (optional, defaults to "ipam4cloud")
- `environment`: Environment name (optional, defaults to "dev")
- `instance_type`: EC2 instance type (optional, defaults to "t3.xlarge")
- `db_instance_class`: RDS instance class (optional, defaults to "db.t3.micro")
- `repository_url`: Git repository URL (optional)

Edit `network.auto.tfvars` and update:
- `vpc_id`: Your VPC ID (replace the placeholder)
- `db_subnet_ids`: List of at least 2 subnet IDs in different AZs (required for RDS)
- `ec2_subnet_id`: Subnet ID for EC2 instance

**Note**: SSH key pairs are automatically generated by Terraform. The private key will be saved as `ipam4cloud-aws-rds-deployer-key` in the current directory. If you prefer to use an existing AWS key pair, set `create_key_pair = false` and `existing_key_name = "your-key-name"` in `terraform.tfvars`.

### 2. Deploy Infrastructure

```bash
terraform init
terraform plan
terraform apply
```

### 3. Wait for Deployment

Deployment typically takes ~15-20 minutes:
- RDS instance creation: ~5-10 minutes
- EC2 instance creation: ~2-3 minutes
- User-data script execution: ~5-10 minutes

### 4. Access the Application

After deployment, Terraform will output:
- Instance public IP
- RDS endpoint
- Private key file path
- SSH command
- Application URLs

Access the services:
- **Admin Portal**: http://<instance-public-ip>:8080
- **Read-Only Portal**: http://<instance-public-ip>:8081
- **Backend API**: http://<instance-public-ip>:8000

### 5. SSH to Instance

If a new key pair was created (default), use:
```bash
ssh -i ipam4cloud-aws-rds-deployer-key ec2-user@<instance-public-ip>
```

The exact key filename will be shown in the Terraform output (`private_key_file`). The key name format is `ipam4cloud-aws-rds-deployer-key`.

Check initialization status:
```bash
sudo cloud-init status --wait
sudo tail -50 /var/log/user-data.log
```

## Configuration

### Variables

| Variable | Description | Required | Default | File |
|----------|-------------|----------|---------|------|
| `aws_region` | AWS region for infrastructure deployment | Yes | - | `terraform.tfvars` |
| `aws_sync_region` | AWS region for VPC sync operations | Yes | - | `terraform.tfvars` |
| `aws_account_id` | AWS Account ID for sync operations | Yes | - | `terraform.tfvars` |
| `vpc_id` | VPC ID where resources will be deployed | Yes | - | `network.auto.tfvars` |
| `db_subnet_ids` | List of subnet IDs for DB subnet group (min 2 in different AZs) | Yes | - | `network.auto.tfvars` |
| `ec2_subnet_id` | Subnet ID for EC2 instance | Yes | - | `network.auto.tfvars` |
| `project_name` | Project name for resource naming | No | `ipam4cloud` | `terraform.tfvars` |
| `environment` | Environment name (dev/staging/prod) | No | `dev` | `terraform.tfvars` |
| `instance_type` | EC2 instance type | No | `t3.xlarge` | `terraform.tfvars` |
| `root_volume_size` | Root volume size in GB | No | `50` | `terraform.tfvars` |
| `db_instance_class` | RDS instance class | No | `db.t3.micro` | `terraform.tfvars` |
| `db_engine_version` | PostgreSQL engine version | No | `15.15` | `terraform.tfvars` |
| `db_allocated_storage` | Initial allocated storage in GB | No | `20` | `terraform.tfvars` |
| `db_max_allocated_storage` | Maximum allocated storage for autoscaling in GB | No | `100` | `terraform.tfvars` |
| `db_multi_az` | Enable Multi-AZ deployment for high availability | No | `false` | `terraform.tfvars` |
| `db_backup_retention_days` | Number of days to retain backups | No | `7` | `terraform.tfvars` |
| `db_deletion_protection` | Enable deletion protection | No | `false` | `terraform.tfvars` |
| `repository_url` | Git repository URL | No | GitHub default | `terraform.tfvars` |
| `create_key_pair` | Automatically create new SSH key pair | No | `true` | `terraform.tfvars` |
| `existing_key_name` | Existing AWS key pair name (if `create_key_pair = false`) | Conditional | - | `terraform.tfvars` |

**Note**: SSH key pairs are automatically generated by Terraform when `create_key_pair = true` (default). The private key is saved as `ipam4cloud-aws-rds-deployer-key` and the public key as `ipam4cloud-aws-rds-deployer-key.pub` in the deployment directory.

## Managing the Application

Once deployed, you can SSH to the instance and manage containers:

```bash
# SSH to instance (use the key file shown in Terraform output)
ssh -i ipam4cloud-aws-rds-deployer-key ec2-user@<instance-public-ip>

# Navigate to application directory
cd ~/ipam4cloud

# Use docker compose to control containers
cd containers
docker compose -f docker-compose.rds.yml ps      # Check status
docker compose -f docker-compose.rds.yml logs    # View logs
docker compose -f docker-compose.rds.yml restart backend  # Restart backend
```

## Troubleshooting

### Backend Container Keeps Restarting

**Check database connection**:
```bash
# On EC2 instance
cd ~/ipam4cloud
cat .env | grep DATABASE_URL
# Password should be URL-encoded (contain % characters)

# Test connection
export $(grep -v '^#' .env | xargs)
psql $DATABASE_URL -c "SELECT 1;"
```

**Restart backend**:
```bash
cd ~/ipam4cloud/containers
export $(grep -v '^#' ../.env | xargs)
docker compose -f docker-compose.rds.yml restart backend
```

### Database Not Initialized

The user-data script initializes the database automatically. If it failed:

```bash
# On EC2 instance
cd ~/ipam4cloud
export PGPASSWORD='<password-from-terraform-output>'
psql -h <rds-endpoint> -p 5432 -U prefix_user -d prefix_management -f containers/init/01_schema.sql
psql -h <rds-endpoint> -p 5432 -U prefix_user -d prefix_management -f containers/init/02_seed_data.sql
psql -h <rds-endpoint> -p 5432 -U prefix_user -d prefix_management -f containers/init/03_idempotency.sql
```

**Get RDS password**:
```bash
terraform output -raw rds_password
```

**Get RDS endpoint**:
```bash
terraform output rds_endpoint
```

### Instance Not Initializing

1. Check cloud-init status:
   ```bash
   sudo cloud-init status
   ```

2. View user-data logs:
   ```bash
   sudo tail -f /var/log/user-data.log
   ```

3. Check Docker installation:
   ```bash
   docker --version
   docker compose version
   ```

### Application Not Accessible

1. Check security group rules (ports 22, 8000, 8080, 8081 should be open)
2. Verify containers are running:
   ```bash
   docker ps
   ```
3. Check container logs:
   ```bash
   cd ~/ipam4cloud/containers
   docker compose -f docker-compose.rds.yml logs
   ```

### RDS Connection Issues

1. Verify RDS security group allows connections from EC2 security group
2. Check RDS instance status:
   ```bash
   aws rds describe-db-instances --db-instance-identifier <instance-id>
   ```
3. Test connection from EC2:
   ```bash
   psql -h <rds-endpoint> -p 5432 -U prefix_user -d prefix_management
   ```

## Cleanup

To destroy all resources:

```bash
terraform destroy
```

**Warning**: This will delete the RDS instance, EC2 instance, and all data. Ensure you have backups if needed. If `db_deletion_protection` is enabled, you'll need to disable it first or modify the RDS instance manually.

## Cost Estimation

- **EC2 t3.xlarge**: ~$150/month (varies by region)
- **RDS db.t3.micro**: ~$15/month (varies by region)
- **RDS Storage (20GB)**: ~$2.30/month
- **EBS Storage (50GB gp3)**: ~$4/month
- **Data Transfer**: Varies

Total estimated cost: ~$171/month (excluding data transfer)

**Note**: Costs vary significantly by region and usage. RDS Multi-AZ deployments cost approximately 2x the single-AZ cost.

## Security Considerations

1. **SSH Access**: Security group allows SSH from 0.0.0.0/0. Consider restricting to your IP.
2. **RDS Access**: RDS security group should only allow connections from EC2 security group. Verify this is configured correctly.
3. **Database Port**: Port 5432 should not be publicly accessible. Ensure RDS is in private subnets or has restricted security group rules.
4. **Application Ports**: Ports 8000, 8080, 8081 are open. Consider adding authentication.
5. **Key Management**: 
   - SSH keys are automatically generated by Terraform and saved locally
   - Keep your private key (`*-deployer-key`) secure and never commit it to git
   - The `.gitignore` file already excludes these keys
6. **Sensitive Files**: 
   - `network.auto.tfvars` contains VPC and subnet IDs specific to your environment
   - `terraform.tfvars` may contain AWS account IDs
   - These files are gitignored - never commit them to version control
7. **RDS Credentials**: 
   - Database password is automatically generated and stored in Terraform state
   - Use `terraform output -raw rds_password` to retrieve it securely
   - Never commit Terraform state files to version control

## Support

For issues or questions:
1. Check the [Design Document](../DESIGN.md) for architecture details
2. Review Terraform outputs for connection details
3. Check AWS CloudWatch logs for EC2 and RDS
4. Review application logs using `docker compose -f docker-compose.rds.yml logs`
5. Check RDS instance status in AWS Console
